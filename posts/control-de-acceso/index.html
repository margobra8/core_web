<!doctype html><html lang=es><head><title>Control de acceso :: CORE Study Hub</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="En este post se detalla como hacer que ciertas páginas solo se puedan ver un determinado número de veces o durante unas horas del día"><meta name=keywords content="core,etsit,parcial,exámenes,tips,estudiar,express,html,js,javascript,etsit-upm,ejs,node,git,node.js"><meta name=robots content="noodp"><link rel=canonical href=/posts/control-de-acceso/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/green.css><link rel=apple-touch-icon href=/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=/img/favicon/green.png><meta name=twitter:card content="summary"><meta name=twitter:site content="https://core.marquitos.space/"><meta name=twitter:creator content="usualmarcos"><meta property="og:locale" content="es"><meta property="og:type" content="article"><meta property="og:title" content="Control de acceso"><meta property="og:description" content="En este post se detalla como hacer que ciertas páginas solo se puedan ver un determinado número de veces o durante unas horas del día"><meta property="og:url" content="/posts/control-de-acceso/"><meta property="og:site_name" content="CORE Study Hub"><meta property="og:image" content="/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2021-05-31 20:04:17 +0200 +0200"></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>CORE Study Hub</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><ul class=menu__sub-inner><li class=menu__sub-inner-more-trigger>Menú ▾</li><ul class="menu__sub-inner-more hidden"><li><a href=https://github.com/margobra8/quiz_2020>Mi Entrega9_groups</a></li><li><a href=https://me.marquitos.space/>Sobre mí</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=https://github.com/margobra8/quiz_2020>Mi Entrega9_groups</a></li><li><a href=https://me.marquitos.space/>Sobre mí</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=/posts/control-de-acceso/>Control de acceso</a></h1><div class=post-meta><span class=post-date>2021-05-31</span>
<span class=post-author>:: Marcos Gómez</span></div><span class=post-tags>#<a href=/tags/js/>js</a>&nbsp;
#<a href=/tags/html/>html</a>&nbsp;
#<a href=/tags/router/>router</a>&nbsp;
#<a href=/tags/routes/>routes</a>&nbsp;
#<a href=/tags/sequelize/>sequelize</a>&nbsp;
#<a href=/tags/models/>models</a>&nbsp;
#<a href=/tags/controllers/>controllers</a>&nbsp;
#<a href=/tags/views/>views</a>&nbsp;</span><div class=post-content><div><p>En el examen nos pueden pedir restringir el acceso a ciertas páginas, pudiendo éstas ser visualizadas un número determinado de veces o sólo por algunos usuarios durante ciertas horas del día.</p><p>Iremos paso a paso viendo que modificaciones se tienen que hacer en cada caso. Todos estos controles se implementan como middlewares en el controlador <code>controllers/session.js</code>.</p><h2 id=acceso-a-cada-página-permitido-sólo-un-número-x-de-veces>Acceso a cada página permitido sólo un número X de veces<a href=#acceso-a-cada-página-permitido-sólo-un-número-x-de-veces class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Este problema lo podemos resolver de varias maneras dependiendo de lo que queramos conseguir. Si queremos que el número de accesos realizados se resetee al volver a entrar a la página, haremos el control de acceso a través de <code>session</code>. Si queremos que el cambio sea persistente y para todos los usuarios, modificaremos los modelos o usaremos una variable global.</p><h3 id=control-no-persistente-mediante-session>Control no persistente (mediante <code>session</code>)<a href=#control-no-persistente-mediante-session class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Para hacer esto posible crearemos un nuevo middleware que va a ir generando y almacenando el número de veces que entramos en una página y el límite que establezcamos lo fijaremos en una variable que podemos tocar. Haremos dos versiones de esto: que el contador sea dependiente de cada página, o que el contador se aplique y tenga en cuenta para todas las páginas.</p><h4 id=un-contador-para-cada-página>Un contador para cada página<a href=#un-contador-para-cada-página class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Crearemos un controlador en <code>controllers/session.js</code> que se encargue de verificar el acceso y contabilizar los accesos nuevos.</p><div class=collapsable-code><input id=637852194 type=checkbox>
<label for=637852194><span class=collapsable-code__language>js</span>
<span class=collapsable-code__title>controllers/session.js</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span></label><pre class=language-js><code>
exports.visitLimitPerPage = (req, res, next) =&gt; {
    // establecemos el límite de visitas para cada página
    const VISIT_LIMIT = 10;

    // almacenamos en una variable la ruta a la que accede el usuario
    const url = req.url;

    // creamos el objeto req.session.visits donde almacenaremos un objeto con las visitas a cada página o cogemos el objeto ya presente
    req.session.visits = req.session.visits || {};

    // almacenamos un nuevo valor de visita para cada ruta o creamos la primera visita a esa página
    req.session.visits[url] = req.session.visits[url] || 0;
    req.session.visits[url]&#43;&#43;;

    // comprobamos que no se excede el número de visitas permitidas para esa página, en ese caso continuamos al siguiente mw, si no, mostramos mensaje y volvemos al home
    if (req.session.visits[url] &lt;= VISIT_LIMIT) {
        next();
    } else {
        req.flash(&#34;error&#34;, &#34;You have depleted the amount of visits permitted to &#34; &#43; url);
        res.redirect(&#34;/&#34;);
    }
}
</code></pre></div><p>Ahora sólo tenemos que incluir este middleware <strong>antes</strong> del resto de middlewares para las rutas en las que las queramos aplicar, por ejemplo:</p><div class=collapsable-code><input id=932846751 type=checkbox>
<label for=932846751><span class=collapsable-code__language>js</span>
<span class=collapsable-code__title>routes/index.js</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span></label><pre class=language-js><code>
router.get(&#34;/groups&#34;, sessionController.visitLimitPerPage, groupController.index);
</code></pre></div><h4 id=un-contador-para-todas-las-páginas>Un contador para todas las páginas<a href=#un-contador-para-todas-las-páginas class=hanchor arialabel=Anchor>&#8983;</a></h4><p>Modificando un poco el middleware anterior se puede conseguir lo mismo pero con un contador común en <code>session</code>:</p><div class=collapsable-code><input id=962734815 type=checkbox>
<label for=962734815><span class=collapsable-code__language>js</span>
<span class=collapsable-code__title>controllers/session.js</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span></label><pre class=language-js><code>
exports.visitLimitGeneral = (req, res, next) =&gt; {
    // establecemos el límite de visitas general
    const VISIT_LIMIT = 10;

    // creamos el objeto req.session.visits donde almacenaremos un objeto con las visitas totales o cogemos el objeto ya presente
    req.session.visits = req.session.visits || 0;
    req.session.visits&#43;&#43;;

    // comprobamos que no se excede el número de visitas global permitido, en ese caso continuamos al siguiente mw, si no, mostramos mensaje y volvemos al home
    if (req.session.visits &lt;= VISIT_LIMIT) {
        next();
    } else {
        req.flash(&#34;error&#34;, &#34;You have depleted the amount of visits permitted to &#34; &#43; url);
        res.redirect(&#34;/&#34;);
    }
}
</code></pre></div><p>Añadiríamos este middleware a todas las rutas que lo necesiten como en el apartado anterior.</p><h3 id=contador-persistente>Contador persistente<a href=#contador-persistente class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Para que la cuenta se mantenga durante sesiones es necesario que se almacene de manera persistente. La manera idónea sería crear un modelo <code>Page</code> que tuviese los campos de <code>url</code> y <code>visits</code>, creáramos todas las páginas actuales con un seeder y las migraciones correspondientes. Sin embargo, esto es muy tedioso y largo. Optaremos por otro método similar al anterior pero empleando una variable global nutriéndonos del objeto <code>global</code> que proporciona node.</p><p>En este caso sólo implementaré la situación de cuentas distintas por página porque es el caso más particular, se deja la implementación del caso del contador general persistente para el lector.</p><div class=collapsable-code><input id=269734518 type=checkbox>
<label for=269734518><span class=collapsable-code__language>js</span>
<span class=collapsable-code__title>controllers/session.js</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span></label><pre class=language-js><code>
exports.visitLimitPerPageGlobal = (req, res, next) =&gt; {
    // establecemos el límite de visitas para cada página
    const VISIT_LIMIT = 10;

    // almacenamos en una variable la ruta a la que accede el usuario
    const url = req.url;

    // creamos el objeto global.visits donde almacenaremos un objeto con las visitas a cada página o cogemos el objeto ya presente
    global.visits = global.visits || {};

    // almacenamos un nuevo valor de visita para cada ruta o creamos la primera visita a esa página
    global.visits[url] = global.visits[url] || 0;
    global.visits[url]&#43;&#43;;

    // comprobamos que no se excede el número de visitas permitidas para esa página, en ese caso continuamos al siguiente mw, si no, mostramos mensaje y volvemos al home
    if (global.visits[url] &lt;= VISIT_LIMIT) {
        next();
    } else {
        req.flash(&#34;error&#34;, &#34;You have depleted the amount of visits permitted to &#34; &#43; url);
        res.redirect(&#34;/&#34;);
    }
}
</code></pre></div><p>Como siempre añadiríamos este middleware a las rutas que lo precisaran.</p><h2 id=acceso-a-las-páginas-permitido-a-ciertos-usuarios-durante-ciertas-horas>Acceso a las páginas permitido a ciertos usuarios durante ciertas horas<a href=#acceso-a-las-páginas-permitido-a-ciertos-usuarios-durante-ciertas-horas class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Ahora trataremos el caso en el que queremos que los accesos estén restringidos a ciertos usuarios durante ciertas horas del día. Aquí expongo 3 middlewares que realizan funcionalidades distintas según lo que queremos conseguir:</p><ul><li>acceso restringido a un rango de horas para cualquier usuario</li><li>acceso restringido un rango de horas para admins y el resto de tiempo para todos los usuarios</li><li>acceso restringido sólo a admins durante una franja horaria determinada y cerrado para todos el resto del tiempo (con cascada de middlewares).</li></ul><h3 id=acceso-restringido-durante-un-rango-de-horasfecha-para-cualquier-usuario>Acceso restringido durante un rango de horas/fecha para cualquier usuario<a href=#acceso-restringido-durante-un-rango-de-horasfecha-para-cualquier-usuario class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Vamos a suponer que queremos que cualquier usuario sólo pueda entrar entre las 17:00 h y las 18:59 h a las páginas que decidamos. Para eso necesitamos crear un nuevo middleware en <code>session</code>.</p><div class=collapsable-code><input id=356481729 type=checkbox>
<label for=356481729><span class=collapsable-code__language>js</span>
<span class=collapsable-code__title>controllers/session.js</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span></label><pre class=language-js><code>
exports.hourRestrictionAnyUser = (req, res, next) =&gt; {
    // establecemos la hora inicio y final de la franja donde admitiremos visitas
    const LOW_HOUR = 17;
    const HIGH_HOUR = 19;

    // obtenemos la hora actual en el momento que se hace la request y sacamos la hora (sólo número de hora en formato 24h)
    const now = new Date().getHours();

    // comprobamos si estamos en esa franja, si es así continuamos al next mw, si no mostramos error y vamos a home.
    if (now &gt;= LOW_HOUR &amp;&amp; now &lt; HIGH_HOUR) {
        next();
    } else {
        req.flash(&#34;error&#34;, &#34;No visits allowed for this page at &#34; &#43; new Date());
        res.redirect(&#34;/&#34;);
    }
}
</code></pre></div><h3 id=acceso-restringido-mixto-basado-en-tiempo>Acceso restringido mixto basado en tiempo<a href=#acceso-restringido-mixto-basado-en-tiempo class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Vamos a explorar ahora la situación en la que dejemos pasar a todos los usuarios a una determinada página, pero que durante un rango de horas sólo sea accesible para admins.</p><div class=collapsable-code><input id=792436518 type=checkbox>
<label for=792436518><span class=collapsable-code__language>js</span>
<span class=collapsable-code__title>controllers/session.js</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span></label><pre class=language-js><code>
exports.hourRestrictionMixed = (req, res, next) =&gt; {
    // establecemos la hora inicio y final de la franja donde admitiremos visitas solo de admins
    const LOW_HOUR = 17;
    const HIGH_HOUR = 19;

    // vemos si el usuario logueado es admin
    const isAdmin = !!req.loginUser.isAdmin;

    // obtenemos la hora actual en el momento que se hace la request y sacamos la hora (sólo número de hora en formato 24h)
    const now = new Date().getHours();

    // comprobamos si estamos en la *franja prohibida*, si es así vemos si es admin y si ok continuamos al next mw, si no mostramos error y vamos a home.
    // si no estamos en la franja pasamos ok
    if (now &gt;= LOW_HOUR &amp;&amp; now &lt; HIGH_HOUR) {
        if (isAdmin) {
            next();
        } else {
            req.flash(&#34;error&#34;, &#34;No visits allowed from normal users for this page at &#34; &#43; new Date());
            res.redirect(&#34;/&#34;);
        }
    } else {
        next();
    }
}
</code></pre></div><p>Aplicaríamos este middleware antes como cualquier otro.</p><h3 id=acceso-restringido-para-admins-durante-una-franja-de-tiempo-y-para-nadie-fuera-de-ella>Acceso restringido para admins durante una franja de tiempo y para nadie fuera de ella<a href=#acceso-restringido-para-admins-durante-una-franja-de-tiempo-y-para-nadie-fuera-de-ella class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Ahora veremos el caso en el que emplearemos cascadas de middlewares para implementar las funcionalidades que queramos. Esto es por si en el examen nos dan middlewares ya hechos y disponibles y nos piden usarlos. Para este ejemplo consideraremos que tenemos un middleware ya proporcionado que es <code>sessionController.isAdmin</code> que nos deja continuar si somos admins y hemos implementado el primer middleware por horas de este post: <code>sessionController.hourRestrictionAnyUser</code>.</p><p>El truco está en usar estos dos middlewares para comprobar que somos admins primero, y luego comprobar si estamos en las horas permitidas, aunque hayamos diseñado el middleware para &ldquo;todos los usuarios&rdquo;. Esto es posible gracias a la independencia de los middlewares: uno se centra en comprobar el acceso basado en tiempo y el otro basado en roles. Si ambos los usamos conjuntamente crearemos una condición no-excluyente. Claro está que si necesitamos comportamientos más avanzados podemos implementar soluciones más avanzadas como <code>sessionController.hourRestrictionMixed</code>.</p><p>Para hacer este encadenado de middlewares procedemos así:</p><div class=collapsable-code><input id=568317942 type=checkbox>
<label for=568317942><span class=collapsable-code__language>js</span>
<span class=collapsable-code__title>routes/index.js</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span></label><pre class=language-js><code>
routes.get(&#34;/scores&#34;, sessionController.isAdmin, sessionController.hourRestrictionAnyUser, scoresController.index);
</code></pre></div><p>Esto es todo por este post :)</p></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2021 Marcos Gómez</span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script><footer class=footer><div class=footer__inner><div class="copyright copyright--user">La información mostrada en este sitio es de carácter puramente informativo
y sin ninguna garantía de que sea correcta. Los trozos de código se
proporcionan "como están", sin ningún tipo de garantía o liabilidad.</div></div></footer></div></body></html>