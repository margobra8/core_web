<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>js on CORE Study Hub</title><link>/tags/js/</link><description>Recent content in js on CORE Study Hub</description><generator>Hugo -- gohugo.io</generator><language>es</language><copyright>Marcos Gómez</copyright><lastBuildDate>Mon, 31 May 2021 20:04:17 +0200</lastBuildDate><atom:link href="/tags/js/index.xml" rel="self" type="application/rss+xml"/><item><title>Control de acceso</title><link>/posts/control-de-acceso/</link><pubDate>Mon, 31 May 2021 20:04:17 +0200</pubDate><guid>/posts/control-de-acceso/</guid><description>En el examen nos pueden pedir restringir el acceso a ciertas páginas, pudiendo éstas ser visualizadas un número determinado de veces o sólo por algunos usuarios durante ciertas horas del día.
Iremos paso a paso viendo que modificaciones se tienen que hacer en cada caso. Todos estos controles se implementan como middlewares en el controlador controllers/session.js.
Acceso a cada página permitido sólo un número X de veces Este problema lo podemos resolver de varias maneras dependiendo de lo que queramos conseguir.</description><content>&lt;p>En el examen nos pueden pedir restringir el acceso a ciertas páginas, pudiendo éstas ser visualizadas un número determinado de veces o sólo por algunos usuarios durante ciertas horas del día.&lt;/p>
&lt;p>Iremos paso a paso viendo que modificaciones se tienen que hacer en cada caso. Todos estos controles se implementan como middlewares en el controlador &lt;code>controllers/session.js&lt;/code>.&lt;/p>
&lt;h2 id="acceso-a-cada-página-permitido-sólo-un-número-x-de-veces">Acceso a cada página permitido sólo un número X de veces&lt;/h2>
&lt;p>Este problema lo podemos resolver de varias maneras dependiendo de lo que queramos conseguir. Si queremos que el número de accesos realizados se resetee al volver a entrar a la página, haremos el control de acceso a través de &lt;code>session&lt;/code>. Si queremos que el cambio sea persistente y para todos los usuarios, modificaremos los modelos o usaremos una variable global.&lt;/p>
&lt;h3 id="control-no-persistente-mediante-session">Control no persistente (mediante &lt;code>session&lt;/code>)&lt;/h3>
&lt;p>Para hacer esto posible crearemos un nuevo middleware que va a ir generando y almacenando el número de veces que entramos en una página y el límite que establezcamos lo fijaremos en una variable que podemos tocar. Haremos dos versiones de esto: que el contador sea dependiente de cada página, o que el contador se aplique y tenga en cuenta para todas las páginas.&lt;/p>
&lt;h4 id="un-contador-para-cada-página">Un contador para cada página&lt;/h4>
&lt;p>Crearemos un controlador en &lt;code>controllers/session.js&lt;/code> que se encargue de verificar el acceso y contabilizar los accesos nuevos.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="463728159" type="checkbox" />
&lt;label for="463728159">
&lt;span class="collapsable-code__language">js&lt;/span>
&lt;span class="collapsable-code__title">controllers/session.js&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-js" >&lt;code>
exports.visitLimitPerPage = (req, res, next) =&amp;gt; {
// establecemos el límite de visitas para cada página
const VISIT_LIMIT = 10;
// almacenamos en una variable la ruta a la que accede el usuario
const url = req.url;
// creamos el objeto req.session.visits donde almacenaremos un objeto con las visitas a cada página o cogemos el objeto ya presente
req.session.visits = req.session.visits || {};
// almacenamos un nuevo valor de visita para cada ruta o creamos la primera visita a esa página
req.session.visits[url] = req.session.visits[url] || 0;
req.session.visits[url]&amp;#43;&amp;#43;;
// comprobamos que no se excede el número de visitas permitidas para esa página, en ese caso continuamos al siguiente mw, si no, mostramos mensaje y volvemos al home
if (req.session.visits[url] &amp;lt;= VISIT_LIMIT) {
next();
} else {
req.flash(&amp;#34;error&amp;#34;, &amp;#34;You have depleted the amount of visits permitted to &amp;#34; &amp;#43; url);
res.redirect(&amp;#34;/&amp;#34;);
}
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Ahora sólo tenemos que incluir este middleware &lt;strong>antes&lt;/strong> del resto de middlewares para las rutas en las que las queramos aplicar, por ejemplo:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="827954613" type="checkbox" />
&lt;label for="827954613">
&lt;span class="collapsable-code__language">js&lt;/span>
&lt;span class="collapsable-code__title">routes/index.js&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-js" >&lt;code>
router.get(&amp;#34;/groups&amp;#34;, sessionController.visitLimitPerPage, groupController.index);
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h4 id="un-contador-para-todas-las-páginas">Un contador para todas las páginas&lt;/h4>
&lt;p>Modificando un poco el middleware anterior se puede conseguir lo mismo pero con un contador común en &lt;code>session&lt;/code>:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="894613527" type="checkbox" />
&lt;label for="894613527">
&lt;span class="collapsable-code__language">js&lt;/span>
&lt;span class="collapsable-code__title">controllers/session.js&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-js" >&lt;code>
exports.visitLimitGeneral = (req, res, next) =&amp;gt; {
// establecemos el límite de visitas general
const VISIT_LIMIT = 10;
// creamos el objeto req.session.visits donde almacenaremos un objeto con las visitas totales o cogemos el objeto ya presente
req.session.visits = req.session.visits || 0;
req.session.visits&amp;#43;&amp;#43;;
// comprobamos que no se excede el número de visitas global permitido, en ese caso continuamos al siguiente mw, si no, mostramos mensaje y volvemos al home
if (req.session.visits &amp;lt;= VISIT_LIMIT) {
next();
} else {
req.flash(&amp;#34;error&amp;#34;, &amp;#34;You have depleted the amount of visits permitted to &amp;#34; &amp;#43; url);
res.redirect(&amp;#34;/&amp;#34;);
}
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Añadiríamos este middleware a todas las rutas que lo necesiten como en el apartado anterior.&lt;/p>
&lt;h3 id="contador-persistente">Contador persistente&lt;/h3>
&lt;p>Para que la cuenta se mantenga durante sesiones es necesario que se almacene de manera persistente. La manera idónea sería crear un modelo &lt;code>Page&lt;/code> que tuviese los campos de &lt;code>url&lt;/code> y &lt;code>visits&lt;/code>, creáramos todas las páginas actuales con un seeder y las migraciones correspondientes. Sin embargo, esto es muy tedioso y largo. Optaremos por otro método similar al anterior pero empleando una variable global nutriéndonos del objeto &lt;code>global&lt;/code> que proporciona node.&lt;/p>
&lt;p>En este caso sólo implementaré la situación de cuentas distintas por página porque es el caso más particular, se deja la implementación del caso del contador general persistente para el lector.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="598627431" type="checkbox" />
&lt;label for="598627431">
&lt;span class="collapsable-code__language">js&lt;/span>
&lt;span class="collapsable-code__title">controllers/session.js&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-js" >&lt;code>
exports.visitLimitPerPageGlobal = (req, res, next) =&amp;gt; {
// establecemos el límite de visitas para cada página
const VISIT_LIMIT = 10;
// almacenamos en una variable la ruta a la que accede el usuario
const url = req.url;
// creamos el objeto global.visits donde almacenaremos un objeto con las visitas a cada página o cogemos el objeto ya presente
global.visits = global.visits || {};
// almacenamos un nuevo valor de visita para cada ruta o creamos la primera visita a esa página
global.visits[url] = global.visits[url] || 0;
global.visits[url]&amp;#43;&amp;#43;;
// comprobamos que no se excede el número de visitas permitidas para esa página, en ese caso continuamos al siguiente mw, si no, mostramos mensaje y volvemos al home
if (global.visits[url] &amp;lt;= VISIT_LIMIT) {
next();
} else {
req.flash(&amp;#34;error&amp;#34;, &amp;#34;You have depleted the amount of visits permitted to &amp;#34; &amp;#43; url);
res.redirect(&amp;#34;/&amp;#34;);
}
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Como siempre añadiríamos este middleware a las rutas que lo precisaran.&lt;/p>
&lt;h2 id="acceso-a-las-páginas-permitido-a-ciertos-usuarios-durante-ciertas-horas">Acceso a las páginas permitido a ciertos usuarios durante ciertas horas&lt;/h2>
&lt;p>Ahora trataremos el caso en el que queremos que los accesos estén restringidos a ciertos usuarios durante ciertas horas del día. Aquí expongo 3 middlewares que realizan funcionalidades distintas según lo que queremos conseguir:&lt;/p>
&lt;ul>
&lt;li>acceso restringido a un rango de horas para cualquier usuario&lt;/li>
&lt;li>acceso restringido un rango de horas para admins y el resto de tiempo para todos los usuarios&lt;/li>
&lt;li>acceso restringido sólo a admins durante una franja horaria determinada y cerrado para todos el resto del tiempo (con cascada de middlewares).&lt;/li>
&lt;/ul>
&lt;h3 id="acceso-restringido-durante-un-rango-de-horasfecha-para-cualquier-usuario">Acceso restringido durante un rango de horas/fecha para cualquier usuario&lt;/h3>
&lt;p>Vamos a suponer que queremos que cualquier usuario sólo pueda entrar entre las 17:00 h y las 18:59 h a las páginas que decidamos. Para eso necesitamos crear un nuevo middleware en &lt;code>session&lt;/code>.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="135629478" type="checkbox" />
&lt;label for="135629478">
&lt;span class="collapsable-code__language">js&lt;/span>
&lt;span class="collapsable-code__title">controllers/session.js&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-js" >&lt;code>
exports.hourRestrictionAnyUser = (req, res, next) =&amp;gt; {
// establecemos la hora inicio y final de la franja donde admitiremos visitas
const LOW_HOUR = 17;
const HIGH_HOUR = 19;
// obtenemos la hora actual en el momento que se hace la request y sacamos la hora (sólo número de hora en formato 24h)
const now = new Date().getHours();
// comprobamos si estamos en esa franja, si es así continuamos al next mw, si no mostramos error y vamos a home.
if (now &amp;gt;= LOW_HOUR &amp;amp;&amp;amp; now &amp;lt; HIGH_HOUR) {
next();
} else {
req.flash(&amp;#34;error&amp;#34;, &amp;#34;No visits allowed for this page at &amp;#34; &amp;#43; new Date());
res.redirect(&amp;#34;/&amp;#34;);
}
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h3 id="acceso-restringido-mixto-basado-en-tiempo">Acceso restringido mixto basado en tiempo&lt;/h3>
&lt;p>Vamos a explorar ahora la situación en la que dejemos pasar a todos los usuarios a una determinada página, pero que durante un rango de horas sólo sea accesible para admins.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="968714253" type="checkbox" />
&lt;label for="968714253">
&lt;span class="collapsable-code__language">js&lt;/span>
&lt;span class="collapsable-code__title">controllers/session.js&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-js" >&lt;code>
exports.hourRestrictionMixed = (req, res, next) =&amp;gt; {
// establecemos la hora inicio y final de la franja donde admitiremos visitas solo de admins
const LOW_HOUR = 17;
const HIGH_HOUR = 19;
// vemos si el usuario logueado es admin
const isAdmin = !!req.loginUser.isAdmin;
// obtenemos la hora actual en el momento que se hace la request y sacamos la hora (sólo número de hora en formato 24h)
const now = new Date().getHours();
// comprobamos si estamos en la *franja prohibida*, si es así vemos si es admin y si ok continuamos al next mw, si no mostramos error y vamos a home.
// si no estamos en la franja pasamos ok
if (now &amp;gt;= LOW_HOUR &amp;amp;&amp;amp; now &amp;lt; HIGH_HOUR) {
if (isAdmin) {
next();
} else {
req.flash(&amp;#34;error&amp;#34;, &amp;#34;No visits allowed from normal users for this page at &amp;#34; &amp;#43; new Date());
res.redirect(&amp;#34;/&amp;#34;);
}
} else {
next();
}
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Aplicaríamos este middleware antes como cualquier otro.&lt;/p>
&lt;h3 id="acceso-restringido-para-admins-durante-una-franja-de-tiempo-y-para-nadie-fuera-de-ella">Acceso restringido para admins durante una franja de tiempo y para nadie fuera de ella&lt;/h3>
&lt;p>Ahora veremos el caso en el que emplearemos cascadas de middlewares para implementar las funcionalidades que queramos. Esto es por si en el examen nos dan middlewares ya hechos y disponibles y nos piden usarlos. Para este ejemplo consideraremos que tenemos un middleware ya proporcionado que es &lt;code>sessionController.isAdmin&lt;/code> que nos deja continuar si somos admins y hemos implementado el primer middleware por horas de este post: &lt;code>sessionController.hourRestrictionAnyUser&lt;/code>.&lt;/p>
&lt;p>El truco está en usar estos dos middlewares para comprobar que somos admins primero, y luego comprobar si estamos en las horas permitidas, aunque hayamos diseñado el middleware para &amp;ldquo;todos los usuarios&amp;rdquo;. Esto es posible gracias a la independencia de los middlewares: uno se centra en comprobar el acceso basado en tiempo y el otro basado en roles. Si ambos los usamos conjuntamente crearemos una condición no-excluyente. Claro está que si necesitamos comportamientos más avanzados podemos implementar soluciones más avanzadas como &lt;code>sessionController.hourRestrictionMixed&lt;/code>.&lt;/p>
&lt;p>Para hacer este encadenado de middlewares procedemos así:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="586491327" type="checkbox" />
&lt;label for="586491327">
&lt;span class="collapsable-code__language">js&lt;/span>
&lt;span class="collapsable-code__title">routes/index.js&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-js" >&lt;code>
routes.get(&amp;#34;/scores&amp;#34;, sessionController.isAdmin, sessionController.hourRestrictionAnyUser, scoresController.index);
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Esto es todo por este post :)&lt;/p></content></item><item><title>Sistema de puntuaciones</title><link>/posts/sistema-de-puntuaciones/</link><pubDate>Mon, 31 May 2021 19:04:17 +0200</pubDate><guid>/posts/sistema-de-puntuaciones/</guid><description>Cuando nos pidan implementar una funcionalidad nueva que se tenga que ver en una nueva &amp;ldquo;página&amp;rdquo; tendremos que tocar las rutas (routes/index.js), las vistas (views/*) e implementar una nueva funcionalidad en el controlador que toque (controllers/*) y en este caso los modelos (models/*).
A mí personalmente me gusta empezar por lo fácil, implementar la ruta o rutas.
Implementación de la ruta Para implementar esta funcionalidad vamos a hacer que el usuario pueda visualizar la puntuación de los grupos en una nueva página.</description><content>&lt;p>Cuando nos pidan implementar una funcionalidad nueva que se tenga que ver en una nueva &amp;ldquo;página&amp;rdquo; tendremos que tocar las rutas (&lt;code>routes/index.js&lt;/code>), las vistas (&lt;code>views/*&lt;/code>) e implementar una nueva funcionalidad en el controlador que toque (&lt;code>controllers/*&lt;/code>) y en este caso los modelos (&lt;code>models/*&lt;/code>).&lt;/p>
&lt;p>A mí personalmente me gusta empezar por lo fácil, implementar la ruta o rutas.&lt;/p>
&lt;h2 id="implementación-de-la-ruta">Implementación de la ruta&lt;/h2>
&lt;p>Para implementar esta funcionalidad vamos a hacer que el usuario pueda visualizar la puntuación de los grupos en una nueva página. Para ello implementaremos una primitiva HTTP &lt;code>GET /scores/&lt;/code> en la que se visualizará una tabla con todas las puntuaciones de todos los grupos. Para gestionar el tema de las puntuaciones crearemos un controlador que se encarge de gestionar todas las primitivas relacionadas con las puntuaciones.&lt;/p>
&lt;p>De momento supondremos que este controller lo llamaremos &lt;code>scoreController&lt;/code>. Vamos a editar el documento de rutas para incluir la nueva ruta.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="561329784" type="checkbox" />
&lt;label for="561329784">
&lt;span class="collapsable-code__language">js&lt;/span>
&lt;span class="collapsable-code__title">routes/index.js&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-js" >&lt;code>
var express = require(&amp;#34;express&amp;#34;);
var router = express.Router();
const quizController = require(&amp;#34;../controllers/quiz&amp;#34;);
const userController = require(&amp;#34;../controllers/user&amp;#34;);
const sessionController = require(&amp;#34;../controllers/session&amp;#34;);
const groupController = require(&amp;#34;../controllers/group&amp;#34;);
// añadimos nuestro controlador que luego crearemos
const scoreController = require(&amp;#34;../controllers/score&amp;#34;);
[...]
// añadimos una nueva ruta al final del archivo para satisfacer nuestro objetivo
router.get(&amp;#34;/scores&amp;#34;, scoreController.index);
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>De esta manera, cuando el usuario haga un GET a esta ruta se pasará el control al middleware &lt;code>index&lt;/code> de &lt;code>scoreController&lt;/code> que ahora crearemos.&lt;/p>
&lt;h1 id="modificación-del-modelo">Modificación del modelo&lt;/h1>
&lt;p>Para acomodar las puntuaciones por grupo tenemos que modificar el modelo de &lt;code>Group&lt;/code> añadiendo un campo de puntuación, eso lo haremos en el archivo del modelo correspondiente:&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="526371489" type="checkbox" />
&lt;label for="526371489">
&lt;span class="collapsable-code__language">js&lt;/span>
&lt;span class="collapsable-code__title">models/group.js&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-js" >&lt;code>
const { Model } = require(&amp;#34;sequelize&amp;#34;);
// Definition of the Group model:
module.exports = (sequelize, DataTypes) =&amp;gt; {
class Group extends Model {}
Group.init(
{
name: {
type: DataTypes.STRING,
unique: true,
validate: { notEmpty: { msg: &amp;#34;Group name must not be empty&amp;#34; } },
},
// añadimos el nuevo campo
score: {
type: DataTypes.INTEGER,
defaultValue: 0
}
},
{
sequelize,
}
);
return Group;
};
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Ahora podemos almacenar en la BBDD la puntuación de cada grupo. Para ello modificaremos &lt;code>groupPlay&lt;/code> para ello.&lt;/p>
&lt;h2 id="creación-del-controlador">Creación del controlador&lt;/h2>
&lt;p>Crearemos un nuevo archivo &lt;code>controllers/score.js&lt;/code> para este fin e implementaremos el método index.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="193457628" type="checkbox" />
&lt;label for="193457628">
&lt;span class="collapsable-code__language">js&lt;/span>
&lt;span class="collapsable-code__title">controllers/score.js&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-js" >&lt;code>
const Sequelize = require(&amp;#34;sequelize&amp;#34;);
const Op = Sequelize.Op;
const { models } = require(&amp;#34;../models&amp;#34;)
[...]
// GET /index
exports.index = async (req, res, next) =&amp;gt; {
try {
const groups = await models.Group.findAll();
res.render(&amp;#34;scores/index.ejs&amp;#34;, {
groups,
});
} catch (error) {
next(error);
}
};
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Se puede ver cómo el código es casi igual al index de groups, y esto es porque al final estamos obteniendo en un array los grupos que hay y sus atributos, entre ellos nombre y puntuación. La diferencia es en el &lt;code>res.render(...)&lt;/code> que ahora llamamos a la nueva vista que crearemos.&lt;/p>
&lt;h2 id="implementación-de-la-vista">Implementación de la vista&lt;/h2>
&lt;p>Crearemos una nueva vista para ello: &lt;code>views/scores/index.ejs&lt;/code> basándonos en el index de la vista de groups ya hecha.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="854196237" type="checkbox" />
&lt;label for="854196237">
&lt;span class="collapsable-code__language">html&lt;/span>
&lt;span class="collapsable-code__title">views/scores/index.ejs&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-html" >&lt;code>
&amp;lt;h1&amp;gt;Scores:&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;% for (var i in groups) { %&amp;gt; &amp;lt;% var group = groups[i]; %&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;a href=&amp;#34;/groups/&amp;lt;%= group.id %&amp;gt;/randomplay&amp;#34;&amp;gt;&amp;lt;%= group.name %&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;%= group.score %&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;% } %&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h2 id="modificación-de-groupcheck">Modificación de &lt;code>groupCheck&lt;/code>&lt;/h2>
&lt;p>Para ir sumando las puntuaciones, modificaremos el controlador de groupCheck. En mi caso lo he llamado randomCheck pero es distinto al de los quizzes individuales porque está en el archivo &lt;code>controllers/group.js&lt;/code>.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="934157862" type="checkbox" />
&lt;label for="934157862">
&lt;span class="collapsable-code__language">js&lt;/span>
&lt;span class="collapsable-code__title">controllers/group.js&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-js" >&lt;code>
[...]
exports.randomCheck = async (req, res, next) =&amp;gt; {
const curGroup = req.load.group;
try {
req.session.groupsRandomPlay = req.session.groupsRandomPlay || {};
req.session.groupsRandomPlay[curGroup.id] = req.session.groupsRandomPlay[
curGroup.id
] || {
resolved: [],
lastQuizId: 0,
};
const answer = req.query.answer || &amp;#34;&amp;#34;;
const result =
answer.toLowerCase().trim() === req.load.quiz.answer.toLowerCase().trim();
if (result) {
req.session.groupsRandomPlay[curGroup.id].lastQuizId = 0;
if (
req.session.groupsRandomPlay[curGroup.id].resolved.indexOf(
req.load.quiz.id
) === -1
) {
req.session.groupsRandomPlay[curGroup.id].resolved.push(
req.load.quiz.id
);
}
const score = req.session.groupsRandomPlay[curGroup.id].resolved.length;
// actualizamos el score del group en cuestión
curGroup.score = score;
curGroup = await curGroup.save({fields: [&amp;#34;score&amp;#34;]});
res.render(&amp;#34;groups/random_result&amp;#34;, {
group: curGroup,
result,
answer,
score,
});
} else {
const score = req.session.groupsRandomPlay[curGroup.id].resolved.length;
delete req.session.groupsRandomPlay[curGroup.id];
res.render(&amp;#34;groups/random_result&amp;#34;, {
group: curGroup,
result,
answer,
score,
});
}
} catch (error) {
next(error);
}
};
[...]
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h2 id="adición-del-enlace">Adición del enlace&lt;/h2>
&lt;p>Ahora sólo nos falta añadir el enlace en el menú de navegación.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="567132489" type="checkbox" />
&lt;label for="567132489">
&lt;span class="collapsable-code__language">html&lt;/span>
&lt;span class="collapsable-code__title">views/scores/index.ejs&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-html" >&lt;code>
&amp;lt;nav class=&amp;#34;main&amp;#34; id=&amp;#34;mainNav&amp;#34; role=&amp;#34;navigation&amp;#34;&amp;gt;
&amp;lt;a href=&amp;#34;/&amp;#34;&amp;gt;Home&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;#34;/quizzes&amp;#34;&amp;gt;Quizzes&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;#34;/author&amp;#34;&amp;gt;Author&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;#34;/groups&amp;#34;&amp;gt;Groups&amp;lt;/a&amp;gt;
&amp;lt;a href=&amp;#34;/scores&amp;#34;&amp;gt;Groups Scores&amp;lt;/a&amp;gt;
&amp;lt;% if (locals.loginUser) { %&amp;gt;
&amp;lt;a href=&amp;#34;/users&amp;#34;&amp;gt;Users&amp;lt;/a&amp;gt;
&amp;lt;% } %&amp;gt;
&amp;lt;/nav&amp;gt;
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Y ya estaría!!!! :)&lt;/p></content></item></channel></rss>